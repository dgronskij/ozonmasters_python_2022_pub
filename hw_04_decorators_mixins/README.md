# day_03_homework

[TOC]

# ETA

| Дата                   | Описание                       |
|------------------------|--------------------------------|
| 2022-04-21 16:00 (Thu) | старт задания                  |
| 2022-04-28 16:00 (Thu) | надо начать ревью до этой даты |
| 2022-05-05 16:00 (Thu) | дедлайн                        |

Вам созданы личные проекты в группе python_2_2022/<user>
У вас там есть права Developer -- это значит, что вы можете пушить в незащищенные ветки.
Ветка `main/master` -- защищенная, поэтому ведите работу в какой-то другой, например, `dev`

В качестве решения принимается Merge Request (не Draft) из вашей рабочей ветки в `main/master` вашей личной репы.

Так мы увидим единый diff вашего решения.

Может получиться так, что какая-то задача сделана не совсем верно.

В этом случае мы предложим в процессе ревью исправить решение.

# Разбалловка

Задание может быть:

- НЕ сдано
- Сдано по базовому треку
    - Должны быть решены
        - 4 заданий из группы `A`
- Сдано по усложненному треку
    - Должны быть решены
        - 4 заданий из группы `A`
        - 1 задание из группы `B`
        - 1 задание из группы `C`

| Секция / задача                         | Группа |
|-----------------------------------------|--------|
| mixin_dict_json                         | A      |
| mixin_repr                              | A      |
| ordering                                | A      |
| timeit                                  | A      |
| cache                                   | B      |
| timeit (с автоподбором кол-ва итераций) | B      |
| attrdict                                | C      |

# Условия задач

## attrdict (обязательно для усложненного трека)

Напишите класс `AttrDict`, который наследуется от `dict` и привносит
следующую функциональность:
- позволяет присваивать атрибуты на любую глубину:
    ```python
    d = AttrDict()
    
    d.a = 1
    d.b.c.d = 2
    assert isinstance(d.b, AttrDict)
    assert isinstance(d.b.c.d, int)
    
    print(d)
    # {"a": 1, "b": {"c": {"d": 2}}}
    ```
- и удалять их:
    ```python
    del d.a
    del d.a.b.c
    ```

## cache (усложненный трек)

Напишите кеширующий декоратор `cache`, который будет уметь декорировать
произвольную функцию и реализует механизм мемоизации
https://en.wikipedia.org/wiki/Memoization

- Декорируемая функция работает детерминированно
- Декорируемая функция может принимать как позиционные, так и именованные 
аргументы
- Гарантируется, что у каждого аргумента декорируемой функции определены
разумные имплементации `__eq__ `, `__hash__` и их можно использовать в
качестве ключей словаря
- Вызовы различные с точки зрения способа передать аргументы (позиционно
или по имени), хоть и реализующие одинаковое итоговое множество аргументов,
считать различными. т.е. вызовы `foo(1, 2)`, `foo(1, b=2)`, `foo(a=1, b=2)`
-- разные для функции `def foo(a, b)`
  - При этом вызовы `foo(b=2, a=1)` и `foo(a=1, b=2)` -- идентичные.
- Размер кеша не ограничен
- Кеширующий враппер должен иметь метод `reset()`, который очищает кеш

## mixin_json_dict (базовый трек)

Напишите 2 класса-миксины:
1. Называется `DictMixin` и определяет метод `to_dict`, который возвращает 
все неприватные атрибуты объекта (но только те, что привязаны непосредственно
к объекту, а не классу / его родителям) и их значения в словаре.
2. Называется `JsonMixin` и определяет метод `to_json`, который возвращает
сериализованное в формат JSON представление результата вызова метода
`to_dict`. Сделайте метод `to_dict` абстрактным с этой миксине.
3. Напишите какой-нибудь небольшой класс, который использует эти миксины.

## mixin_repr (базовый трек)

Допустим, что мы работаем с классами, которые в методе `__init__` принимают
только "публичные" параметры и сохраняют их под такими же именами.
Напишите миксину, которая определяла бы метод `__repr__` согласно
конвенции (`__repr__` представление должно быть "eval-машиночитаемым").

## ordering (базовый трек)

Если некоторый класс имеет методы `__eq__` (или `__ne__`) и любой один из
`__lt__`, `__le__`, `__gt__`, `__ge__`, то недостающие методы сравнения
могут быть написаны через имеющиеся 2.

Например, если класс имеет `__eq__` и `__le__`, то `__gt__` будет
возвращать `True` только если `__le__` возвращает `False`.
И т.д. с остальными методами.

Необходимо написать класс-миксину и декоратор для класса, которые будут
доопределять методы `__ne__`, `__le__`, `__gt__`, `__ge__`, через
`__eq__` и `__lt__`. Таким образом, мы реализуем частный случай того, что мы
описали в первом абзаце.

## timeit (базовый трек)

Напишите декоратор, который позволяет измерять время работы декорируемой
функции несколько раз, а затем возвращает среднее время ее работы.

Декоратор должен работать как фабрика декораторов (и дает возможность
передавать именованный аргумент n, который по умолчанию равен 10):
```python
@timeit(n=200)
def some_job(...): ...
```

И как обычный декоратор (тогда количество итераций будет также равно 10):
```python
@timeit
def some_job(...): ...
```

### Автоподбор кол-ва итераций (усложненный трек)

Декорируемые с помощью `timeit` функции могут иметь разное время работы.

Примеры долгих задач:
- взаимодействие с базой данных по сети может занимать до нескольких секунд
- применение модели машинного обучения может занимать до нескольких секунд

Тогда как другие более простые функции могут работать считанные миллисекунды.

Предлагаетcя написать `timeit` таким образом, чтобы он умел автоматически
подстраивать количество итераций, чтобы постараться укладываться в `max_t`
(добавьте такой именованный аргумент со значением по умолчанию равным 5 секунд).

Работать по автоматической логике `timeit` должен если не передан аргумент `n`, а
если передан, то использовать его. Значение `n` по умолчанию необходимо изменить,
по сравнению с базовым условием задачи, используя sentinel value.
